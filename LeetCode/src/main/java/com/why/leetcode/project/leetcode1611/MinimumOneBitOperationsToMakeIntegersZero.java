package com.why.leetcode.project.leetcode1611;


/**
 * 给你一个整数 n，你需要重复执行多次下述操作将其转换为 0 ：
 * 翻转 n 的二进制表示中最右侧位（第 0 位）。
 * 如果第 (i-1) 位为 1 且从第 (i-2) 位到第 0 位都为 0，则翻转 n 的二进制表示中的第 i 位。
 * 返回将 n 转换为 0 的最小操作次数。
 * 示例 1：
 * 输入：n = 3
 * 输出：2
 * 解释：3 的二进制表示为 "11"
 * "11" -> "01" ，执行的是第 2 种操作，因为第 0 位为 1 。
 * "01" -> "00" ，执行的是第 1 种操作。
 * 示例 2：
 * 输入：n = 6
 * 输出：4
 * 解释：6 的二进制表示为 "110".
 * "110" -> "010" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。
 * "010" -> "011" ，执行的是第 1 种操作。
 * "011" -> "001" ，执行的是第 2 种操作，因为第 0 位为 1 。
 * "001" -> "000" ，执行的是第 1 种操作。
 * -----------------------------------------------------------------------------------------------------------------------------------
 * 解题：
 * 首先要知道什么是格雷码：（https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858?fr=aladdin）
 * 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大
 * 数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。
 * 这里举个例子就明白了：格雷码相邻两个之间只有一个位不同
 * -----------------------------------------------------------------------------------------------------------------------------------
 * 十进制数：         0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |  14  |  15  |
 * - ---------------------------------------------------------------------------------------------------------------------------------
 * 四位自然二进制码： 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
 * -----------------------------------------------------------------------------------------------------------------------------------
 * 四位典型格雷码：  0000 | 0001 | 0011 | 0010 | 0110 | 0111 | 0101 | 0100 | 1100 | 1101 | 1111 | 1110 | 1010 | 1011 | 1001 | 1000 |
 * -----------------------------------------------------------------------------------------------------------------------------------
 * 格雷码表示方法中：第1个数执行op1得到第二个数，第二个数执行op2得到第三个数，第三个数执行op1得到第四个数，。。。。。。。。（类推）
 * 更多的关于格雷码的知识，可以看上面的链接，讲的要详细一些。
 * 这里我们认为输入的n的二进制表示是典型格雷码（用x表示），
 * 那么将n解码为自然二进制码（用y表示），可以明显的观察到，y对应的十进制数就是x变为0需要的执行操作的次数。
 * 例如：
 * 格雷码：0111 ----> 二进制码：0101 ------>十进制数：5 ----->5就是格雷码0111变为格雷码0000需要的操作次数。
 * 所以我们就需要求格雷码对应的二进制码就可以了，对吧。
 * 格雷码解码：从左边第二位起，将每位与左边一位解码后的值异或，作为该位解码后的值（最左边一位依然不变）。
 * 这里开始说一下，为什么下面的代码可以表示解码过程。
 * 例如：设abcd表示四位典型格雷码
 * 解码结果设为nmxy
 * 那么根据格雷码解码：
 * n = a
 * m = a^b
 * x = c^m = c^(a^b) = a^b^c
 * y = d^x = d^(c^(a^b)) = a^b^c^d
 * 所以才有n>>=1这个步骤。
 * 例如：格雷码1110的结果
 * n = 1
 * m = 1^1 = 0
 * x = 1^m = 1^0 = 1
 * y = 0^x = 0^1 = 1
 * 所以解码为二进制数1011------对应十进制数11
 */
public class MinimumOneBitOperationsToMakeIntegersZero {
    public static void main(String[] args) {

        minimumOneBitOperations(3);
    }

    public static int minimumOneBitOperations(int n) {
        int res = 0;
        while (n != 0) {
            res ^= n;
            n = n >> 1;
        }
        return res;
    }
}
